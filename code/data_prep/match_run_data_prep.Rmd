---
title: "Match run data preparation"
subtitle: "Process SRTR heart match run data and add US-CRS scores"
output: html_notebook
---

This notebook processes the SRTR heart match run data by:
1. Loading and filtering heart match run records
2. Adding status codes and blood type information
3. Calculating waiting time from candidate listing date to match date
4. Mapping time-varying US-CRS scores to candidates
5. Saving the processed dataset for visualization and counterfactual analysis
 
```{r}
# Load essential libraries
library(tidyverse)
library(haven)  # For reading SRTR SAS files
library(lubridate)  # For date handling
library(here) # For file path management


# Specify file paths
match_run_path <- here("data", "ptr_hr_20220101_20221231_pub.sas7bdat") 
tx_hr_path <- here("data", "tx_hr.sas7bdat")
cand_thor_path <- here("data", "cand_thor.sas7bdat")
donor_deceased_path <- here("data", "donor_deceased.sas7bdat")
```

```{r}
# load in all sas7bdat files in the data folder
match_run <- read_sas(match_run_path)
tx_hr <- read_sas(tx_hr_path)
cand_thor <- read_sas(cand_thor_path)
donor_deceased <- read_sas(donor_deceased_path)
```


```{r}
heart_only_match_run <- match_run %>%
  select(DONOR_ID, MATCH_ID, MATCH_ORG, MATCH_SUBMIT_DT,
         PX_ID, PTR_SEQUENCE_NUM, PTR_STAT_CD, PTR_STAT_DT, PTR_DISTANCE,
         PTR_CLASS_ALLOC_CAT,
         PTR_OFFER_ACPT) %>%
  filter(MATCH_ORG == "HR") %>%
  arrange(DONOR_ID, PTR_SEQUENCE_NUM) %>%
  mutate(status = case_when(
    PTR_STAT_CD == "2010" ~ "Status 1A (pediatric)",
    PTR_STAT_CD == "2020" ~ "Status 1B (pediatric)",
    PTR_STAT_CD == "2030" ~ "Status 2 (pediatric)",
    PTR_STAT_CD == "2110" ~ "Status 1",
    PTR_STAT_CD == "2120" ~ "Status 2",
    PTR_STAT_CD == "2130" ~ "Status 3",
    PTR_STAT_CD == "2140" ~ "Status 4",
    PTR_STAT_CD == "2150" ~ "Status 5",
    PTR_STAT_CD == "2160" ~ "Status 6",
  ),
  status = factor(status, levels = c(
    "Status 1A (pediatric)",  # Highest priority pediatric
    "Status 1",               # Highest priority adult
    "Status 2",               # Adult Status 2
    "Status 1B (pediatric)",  # Before Status 3 per clinical priority
    "Status 3",               # Adult Status 3
    "Status 4",               # Adult Status 4
    "Status 5",               # Adult Status 5
    "Status 2 (pediatric)",   # Before Status 6 per clinical priority  
    "Status 6"                # Lowest priority adult
  ))) %>%
  left_join(cand_thor %>% select(PX_ID, CAN_ABO, CAN_AGE_AT_LISTING, CAN_LISTING_DT), by = "PX_ID") %>%
  left_join(donor_deceased %>% select(DONOR_ID, DON_ABO, DON_AGE), by = "DONOR_ID") %>%
  left_join(tx_hr %>% select(PX_ID, DONOR_ID, REC_TX_DT), by = c("PX_ID", "DONOR_ID")) %>%
  mutate(
    # Calculate waiting time from listing to match (in days)
    waiting_time_days = as.numeric(difftime(MATCH_SUBMIT_DT, CAN_LISTING_DT, units = "days")),
    recipient_sequence_position = ifelse(is.na(REC_TX_DT), NA, PTR_SEQUENCE_NUM)
  )

donor_ids <- heart_only_match_run %>% pull(DONOR_ID) %>% unique()
```



# Data summary
```{r data-summary}
print(paste("Prepared", nrow(heart_only_match_run), "heart match run records"))
print(paste("Found", length(donor_ids), "unique donors"))

# Waiting time analysis
waiting_time_summary <- heart_only_match_run %>%
  filter(!is.na(waiting_time_days) & waiting_time_days >= 0) %>%
  summarise(
    n_with_waiting_time = n(),
    mean_waiting_days = round(mean(waiting_time_days), 1),
    median_waiting_days = round(median(waiting_time_days), 1),
    min_waiting_days = round(min(waiting_time_days), 1),
    max_waiting_days = round(max(waiting_time_days), 1),
    q25_waiting_days = round(quantile(waiting_time_days, 0.25), 1),
    q75_waiting_days = round(quantile(waiting_time_days, 0.75), 1)
  )

print("Waiting Time Summary:")
print(waiting_time_summary)

# Check for invalid waiting times (negative values)
invalid_waiting_times <- sum(heart_only_match_run$waiting_time_days < 0, na.rm = TRUE)
missing_listing_dates <- sum(is.na(heart_only_match_run$CAN_LISTING_DT))

cat("\nData Quality Check:\n")
cat("- Records with valid waiting times:", waiting_time_summary$n_with_waiting_time, "\n")
cat("- Records with invalid waiting times (negative):", invalid_waiting_times, "\n") 
cat("- Records with missing listing dates:", missing_listing_dates, "\n")

print("Data preparation completed - ready for US-CRS mapping")
```


# load in time-varying US-CRS score
```{r}
#US-CRS scores for each (PX_ID, MATCH_SUBMIT_DT) or (PX_ID, PTR_STAT_DT)

load(here("data", "us_crs_history.Rdata"))

us_crs_data <- pred_data %>%
  select(PX_ID, current_date, prob_surv_6wk)

us_crs_data %>%
  mutate(year = year(current_date)) %>%
  count(year)

us_crs_data
```

# create US CRS mapping table 
```{r}
# maps prob_surv_6wk to a 50 point scale for a given year or set of years
mapping_years <- c(2019, 2020, 2021) 

mapping_table_2019_2021 <- us_crs_data %>%
  mutate(year = year(current_date)) %>%
  filter(year(current_date) %in% mapping_years) %>%
  mutate(us_crs = cut_number(1-prob_surv_6wk, n = 50, labels = 1:50)) %>%
  select(us_crs, prob_surv_6wk) %>%
  distinct() %>%
  group_by(us_crs) %>%
  summarise(min_score = min(prob_surv_6wk, na.rm = TRUE),
            max_score = max(prob_surv_6wk, na.rm = TRUE)) %>%
  mutate(max_score = ifelse(us_crs == 1, 1, max_score ),
         min_score = ifelse(us_crs == 50, 0, min_score))

write_csv(mapping_table_2019_2021, here("mapping_tables", "us_crs_mapping_2019_2021.csv"))
```


```{r}
# Map prob_surv_6wk to 50-point US-CRS scale and return both score and raw probability
us_crs_mapper <- function(patient_id, match_date){
  
  # Get patient's longitudinal US-CRS scores
  patient_us_crs_scores <- us_crs_data %>%
    filter(PX_ID == patient_id) %>%
    select(PX_ID, current_date, prob_surv_6wk)
  
  # Return NA if no data for this patient
  if(nrow(patient_us_crs_scores) == 0) {
    return(list(us_crs_score = NA, prob_surv_6wk = NA))
  }
  
  # Convert match_date to Date if it's not already
  match_date <- as.Date(match_date)
  
  # Find the score closest to the match date (but not after)
  closest_score <- patient_us_crs_scores %>%
    filter(current_date <= match_date) %>%
    arrange(desc(current_date)) %>%
    slice_head(n = 1)
  
  # If no score before/on match date, take the earliest available
  if(nrow(closest_score) == 0) {
    closest_score <- patient_us_crs_scores %>%
      arrange(current_date) %>%
      slice_head(n = 1)
  }
  
  # Extract the probability
  prob_value <- closest_score$prob_surv_6wk
  
  # Map to US-CRS using the mapping table
  us_crs_score <- mapping_table_2019_2021 %>%
    filter(prob_value >= min_score & prob_value <= max_score) %>%
    pull(us_crs)
  
  # Return both values
  if(length(us_crs_score) > 0) {
    return(list(us_crs_score = as.numeric(us_crs_score[1]), prob_surv_6wk = prob_value))
  } else {
    return(list(us_crs_score = NA, prob_surv_6wk = prob_value))
  }
}

us_crs_mapper(heart_only_match_run$PX_ID[2], heart_only_match_run$MATCH_SUBMIT_DT[2])
```

# Apply US-CRS mapping to the full match run dataset
```{r}
# Load parallel processing library
library(furrr)

# Set up parallel processing (use available cores - 1 to keep system responsive)
plan(multisession, workers = availableCores() - 1)

# Add US-CRS scores to the match run data using parallel processing
print(paste("Processing", nrow(heart_only_match_run), "observations with", availableCores() - 1, "cores"))

heart_only_match_run_with_uscrs <- heart_only_match_run %>%
  mutate(
    # Get both US-CRS score and raw probability in one call
    uscrs_results = future_map2(PX_ID, MATCH_SUBMIT_DT, us_crs_mapper,
                               .options = furrr_options(seed = 123),
                               .progress = TRUE)
  ) %>%
  # Extract both values from the list results
  mutate(
    us_crs_score = map_dbl(uscrs_results, ~ .x$us_crs_score %||% NA_real_),
    prob_surv_6wk = map_dbl(uscrs_results, ~ .x$prob_surv_6wk %||% NA_real_)
  ) %>%
  select(-uscrs_results) # Remove the temporary list column 

# Close parallel session
plan(sequential)

print("US-CRS mapping completed!")
```


```{r}
# Check the results
heart_only_match_run_with_uscrs %>%
  select(PX_ID, MATCH_SUBMIT_DT, PTR_STAT_CD, status, us_crs_score) 
```

```{r uscrs-summary}
# Quick summary of US-CRS mapping results
total_records <- nrow(heart_only_match_run_with_uscrs)
with_uscrs <- sum(!is.na(heart_only_match_run_with_uscrs$us_crs_score))
missing_uscrs <- sum(is.na(heart_only_match_run_with_uscrs$us_crs_score))

print(paste("US-CRS Mapping Results:"))
print(paste("- Total records:", total_records))
print(paste("- With US-CRS scores:", with_uscrs, "(", round(with_uscrs/total_records*100, 1), "%)"))
print(paste("- Missing US-CRS scores:", missing_uscrs, "(", round(missing_uscrs/total_records*100, 1), "%)"))

# Basic US-CRS score range
if(with_uscrs > 0) {
  print(paste("- US-CRS score range:", 
              min(heart_only_match_run_with_uscrs$us_crs_score, na.rm = TRUE), 
              "to", 
              max(heart_only_match_run_with_uscrs$us_crs_score, na.rm = TRUE)))
}
```


# Missing US-CRS score analysis and imputation

## Pediatric candidate missingness should be 100%
```{r}
heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING<18) %>% 
  summarise(pediatric_match_run_count = n(),
    us_crs_missing_percentage = 100*mean(is.na(us_crs_score) == TRUE))
```


```{r}
heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING>=18) %>% 
  summarise(us_crs_missing_percentage = 100*mean(is.na(us_crs_score) == TRUE))
```
## Adult candidates with a missing US CRS
```{r}
missing_uscrs_mr_rows <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING >= 18 & is.na(us_crs_score)) %>%
  nrow()

total_adult_mr_rows <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING >= 18) %>%
  nrow()

missing_uscrs_percentage <- (missing_uscrs_mr_rows / total_adult_mr_rows) * 100

print(paste("Adult Match Run Records with Missing US-CRS Scores:"))
print(paste("- Total adult records:", total_adult_mr_rows))
print(paste("- Records with missing US-CRS scores:", missing_uscrs_mr_rows, "(", round(missing_uscrs_percentage, 1), "%)"))
```


```{r}
missing_adults_wo_uscrs <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING>=18 & is.na(us_crs_score)) 

px_ids_missing_uscrs <- missing_adults_wo_uscrs %>% pull(PX_ID) %>% unique()

#missing us_crs scores but in pred_data
mapping_issue_missing_uscrs_px_ids <- pred_data %>%
  filter(PX_ID %in% px_ids_missing_uscrs) %>%
  pull(PX_ID) %>%
  unique()

length(mapping_issue_missing_uscrs_px_ids)

print(paste("Number of unique PX_IDs with missing US-CRS scores but present in pred_data:", length(mapping_issue_missing_uscrs_px_ids)))
```

```{r}
# PX_IDs missing from pred_data entirely
missing_px_id_pred_data <- setdiff(px_ids_missing_uscrs, mapping_issue_missing_uscrs_px_ids)

length(missing_px_id_pred_data)

print(paste("Number of unique PX_IDs with missing US-CRS scores and not present in pred_data:", length(missing_px_id_pred_data)))

all_adult_pxids <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING>=18) %>%
  pull(PX_ID) %>%
  unique()

print(paste("Proportion PX_IDs not in pred_data:", 
            round(length(missing_px_id_pred_data) / length(all_adult_pxids) * 100, 1), "%"))


# Count adult candidates with missing US-CRS scores by status
missing_by_status <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING >= 18 & is.na(us_crs_score)) %>%
  count(status, sort = TRUE, name = "n_missing")

print("\\nAdult candidates with missing US-CRS scores by status:")
print(missing_by_status)

#export match run entries with missing us_crs_scores 
missing_adults_wo_uscrs <- heart_only_match_run_with_uscrs %>%
  filter(CAN_AGE_AT_LISTING>=18 & is.na(us_crs_score)) %>%
  mutate(missing_reason = ifelse(PX_ID %in% missing_px_id_pred_data, "missing from pred_data", "PX_ID in pred_data, but did not map"))

save(missing_adults_wo_uscrs, file = here("data", "adult_match_run_entries_missing_uscrs.Rdata"))
```


# Save processed data
```{r save-data}
# Display final dataset structure
print("Final dataset structure:")
print(colnames(heart_only_match_run_with_uscrs))
print(paste("Dimensions:", nrow(heart_only_match_run_with_uscrs), "rows ×", ncol(heart_only_match_run_with_uscrs), "columns"))

# Final waiting time summary with US-CRS data
final_waiting_summary <- heart_only_match_run_with_uscrs %>%
  filter(!is.na(waiting_time_days) & waiting_time_days >= 0) %>%
  summarise(
    records_with_waiting_time = n(),
    mean_waiting_days = round(mean(waiting_time_days), 1),
    median_waiting_days = round(median(waiting_time_days), 1)
  )

print("Final Waiting Time Summary:")
print(final_waiting_summary)

# Waiting time by status 
waiting_by_status <- heart_only_match_run_with_uscrs %>%
  filter(!is.na(waiting_time_days) & waiting_time_days >= 0) %>%
  group_by(status) %>%
  summarise(
    n = n(),
    mean_waiting = round(mean(waiting_time_days), 1),
    median_waiting = round(median(waiting_time_days), 1),
    .groups = "drop"
  ) %>%
  arrange(desc(mean_waiting))

print("Waiting Time by Status:")
print(waiting_by_status)

# Save the processed dataset with US-CRS scores and waiting time
save(heart_only_match_run_with_uscrs, 
     file = here("data", "heart_only_match_run_with_uscrs.Rdata"))

print("Data saved successfully!")
print("Dataset now includes:")
print("- US-CRS scores and survival probabilities")
print("- Waiting time calculation (listing date to match date)")
print("- Status codes and candidate/donor information")
print("")
print("Next steps:")
print("1. Run 'match_run_visualizations.Rmd' for analysis and visualization")
print("2. Run 'counterfactual_mr.Rmd' for US-CRS based allocation simulation")
print("3. Run 'national_uscrs_allocation.Rmd' for simplified national allocation")
```




